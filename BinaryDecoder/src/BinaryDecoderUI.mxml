<?xml version="1.0" encoding="utf-8"?>
<mx:VDividedBox xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark" 
				xmlns:mx="library://ns.adobe.com/flex/mx"
				creationComplete="init();"
				width="100%" height="100%" xmlns:ui="weave.ui.*">
	<mx:VBox width="100%" height="100%">
		<ui:CodeEditor id="editor"/>
		<mx:HBox>
			<mx:Button label="Load file" click="browse()"/>
			<mx:Button label="Run script" click="validateScript(true)"/>
			<ui:CustomCheckBox id="autorun" selected="true" label="Run script automatically"/>
			<mx:Button label="Save output" click="validateScript(true, true);" enabled="{arrayNotEmpty(files)}"
					   toolTip="Saves the return value from the function to a file."/>
			<ui:HelpComponent>
				var file:FileReference
				function output(result:Object):void
				function curl(url:String):AsyncToken
			</ui:HelpComponent>
		</mx:HBox>
	</mx:VBox>
	<s:TextArea id="output" width="100%" height="100%"/>
	<fx:Script>
		<![CDATA[
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.api.linkBindableProperty;
			import weave.api.registerLinkableChild;
			import weave.compiler.ProxyObject;
			import weave.compiler.StandardLib;
			import weave.core.LinkableFunction;
			import weave.core.UIUtils;
			import weave.core.WeaveXMLDecoder;
			import weave.services.addAsyncResponder;
			
			public const script:LinkableFunction = registerLinkableChild(WeaveAPI.globalHashMap, new LinkableFunction(DEFAULT_SCRIPT, false, true, ['file']), validateScript);
			public const DEFAULT_SCRIPT:String = "\
				function (file) {\n\
					import 'mx.utils.ObjectUtil';\n\
					import 'weave.flascc.readZip';\n\
					import 'weave.flascc.writeZip';\n\
					\n\
					weaveTrace(ObjectUtil.toString(file));\n\
					\n\
					var zip = readZip(file.data);\n\
					\n\
					var amf = zip['weave-amf/history.amf'];\n\
					\n\
					var result = amf.readObject();\n\
					\n\
					return ObjectUtil.toString(result);\n\
				}\
			";
			
			private function runScript(file:FileReference, save:Boolean):*
			{
				var output:* = undefined;
				function lookup(name:String):Object
				{
					if (name == 'file')
						return file;
					if (name == 'curl')
						return curl as Function;
					if (name == 'output')
						return function(result:Object):void {
							saveResult(output = result, save ? file : null);
						};
					
					name = WeaveXMLDecoder.getClassName(name);
					try {
						return getDefinitionByName(name);
					} catch (e:Error) { }
					return null;
				}
				var result:Object = script.call(new ProxyObject(lookup, lookup, null), file);
				if (output !== undefined)
					result = output;
				return result;
			}
			
			private function curl(url:String):AsyncToken
			{
				return WeaveAPI.URLRequestUtils.getURL(null, new URLRequest(url));
			}

			private function init():void
			{
				UIUtils.drawInvisiblePolygon(this);
				
				WeaveAPI.globalHashMap;
				
				linkBindableProperty(script, editor, 'text', 500);
				
				addEventListener(NativeDragEvent.NATIVE_DRAG_ENTER, doDragEnter);
				addEventListener(NativeDragEvent.NATIVE_DRAG_DROP, doDragDrop);
				addEventListener(NativeDragEvent.NATIVE_DRAG_EXIT, doDragExit);
			}
			private function doDragEnter(e:NativeDragEvent):void
			{
				if (e.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
					NativeDragManager.acceptDragDrop(this);
			}
			private function doDragDrop(event:NativeDragEvent):void
			{
				files = event.clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
				files.forEach(loadFile);
			}
			private function doDragExit(e:NativeDragEvent):void
			{
			}
			
			private function browse():void
			{
				var refs:FileReferenceList = new FileReferenceList();
				refs.addEventListener(Event.SELECT, function(event:Event):void {
					files = refs.fileList;
					files.forEach(loadFile);
				});
				refs.browse();
			}
			
			private function loadFile(file:FileReference, index:int, array:Array):void
			{
				file.addEventListener(ProgressEvent.PROGRESS, function(event:ProgressEvent):void {
					output.text = lang('Loading {0}/{1} bytes ({2}%)',
						event.bytesLoaded,
						event.bytesTotal,
						StandardLib.roundSignificant(100 * event.bytesLoaded / event.bytesTotal, 3));
				});
				file.addEventListener(Event.COMPLETE, function(event:Event):void {
					for each (var file:FileReference in files)
						if (file && !file.data)
							return;
					if (autorun.selected)
						validateScript();
				});
				file.load();
			}
			
			private function arrayNotEmpty(array:Array):Boolean
			{
				return array && array.length;
			}
			
			[Bindable] private var files:Array = null;
			private function validateScript(userInitiated:Boolean = false, save:Boolean = false):void
			{
				try
				{
					output.text = '';
					if (userInitiated && !files)
						files = [null];
					if (files && autorun.selected)
					{
						for each (var file:FileReference in files)
						{
							if (file)
								file.data.position = 0;
							var result:* = runScript(file, save);
							if (result != undefined)
								saveResult(result, save ? file : null);
						}
					}
					else
						script.validate();
				}
				catch (e:Error)
				{
					trace(e.getStackTrace());
					output.text = e.message;
				}
			}
			
			/**
			 * @param result The script result.
			 * @param file The input file. If this parameter is given, the script result will be saved to a new file.
			 */
			private function saveResult(result:Object, file:FileReference):void
			{
				if (result is ResultEvent)
					result = (result as ResultEvent).result;
				if (result is FaultEvent)
					result = (result as FaultEvent).fault;
				if (result is AsyncToken)
				{
					addAsyncResponder(result as AsyncToken, saveResult, saveResult, file);
					return;
				}
				
				if (!file)
				{
					output.text = String(result);
					return;
				}
				
				var fileName:String;
				if (result is ByteArray)
				{
					fileName = file.name;
				}
				else if (typeof result == 'object')
				{
					var amfBytes:ByteArray = new ByteArray();
					amfBytes.writeObject(result);
					result = amfBytes;
					fileName = file.name + '.amf';
				}
				else
				{
					fileName = file.name + '.txt';
				}
				
				new FileReference().save(result, fileName);
				output.text = "Saving " + fileName;
			}

		]]>
	</fx:Script>
</mx:VDividedBox>
